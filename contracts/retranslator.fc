{-
    This is the Retranslator contract in the network stress test system.
    It is launched from an external message, very similar in structure
    to a message to a wallet. Until the started chain ends, it forwards
    almost identical messages, which are called hops, to its own copies.
    There are usually several hundred thousand of these messages in one test.
    Every few hops (see txs_per_report in imports/utils.fc), it (i.e. its copy)
    sends a report to the Ð¡ounter contract (counter.fc).
-}

#include "imports/stdlib.fc";
#include "imports/utils.fc";

{-
  _# id:uint16 seqno:uint32 public_key:uint256 own_code:^Cell counter_code:^Cell = Storage;
-}

const monkey_mode = 0;
const max_retranslators = 512;
const max_counters = 12;
const shard_calc_tries_limit = 1;

const chance_base = 65535;
;; This amount should be enough for counter to init
;; and send a report to master:
const report_amount = 90000000; ;; 0.09 TON


(int, int, int, cell, cell) load_data() inline {
  ;; my_id, seqno, pubic_key, own_code, counter_code
  slice ds = get_data().begin_parse();
  return (ds~load_uint(16), ds~load_uint(32),
          ds~load_uint(256), ds~load_ref(), ds.preload_ref());
}

;; arguments for retranslate()
global int same_shard_chance;
global int remaining_hops;
global int split_hops;
global int id;
global int txs_per_report;
global int public_key;
global cell own_code;
global cell counter_code;
global slice payload;

;; variables to set in loops & ifs
global cell next_hop_initstate;
global slice next_hop_address;
global int my_shard;
global int max_shard_depth;
global cell counter_initstate;
global int counter_addr_hash;

() send_report(int any_shard?) impure inline {
  ;; This exceeds the gas limit:
  int found? = false;
  int counter_id = random() % max_counters;
  int first_checked_counter = counter_id; ;; to prevent infinite loop

  do {
    counter_initstate = counter_init(counter_id, public_key, counter_code);
    counter_addr_hash = cell_hash(counter_initstate);
    int counter_shard = counter_addr_hash >> (256 - max_shard_depth);
    found? = any_shard? ? true : (counter_shard == my_shard);
    counter_id += 1;
    if (counter_id >= max_counters) {
      counter_id = 0;
    }
  } until (found? | (counter_id == first_checked_counter)); ;; don't loop it

  int counter_id = random() % max_counters;
  counter_initstate = counter_init(counter_id, public_key, counter_code);
  counter_addr_hash = cell_hash(counter_initstate);

  var report_msg = begin_cell()
    .store_uint(0x10, 6)
    .store_uint(0x400, 11) ;; address serialization and wc
    .store_uint(counter_addr_hash, 256)
    .store_coins(report_amount)
    .store_uint(4 + 2, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1) ;; stateinit presents | body in slice
    .store_ref(counter_initstate)
    .store_uint(id, 16)
    .store_uint(txs_per_report, 16);
  send_raw_message(report_msg.end_cell(), 3);
}

() retranslate(int amount) impure {
  randomize_lt();

  var need_report? = remaining_hops % txs_per_report == 0;
  var any_shard_hop? = amount | ((random() % chance_base) >= same_shard_chance);

  max_shard_depth = max_split_from_config();
  (_, int my_addr_hash) = parse_std_addr(my_address());
  ;; first `max_shard_depth` bits of an address are the shard id
  my_shard = my_addr_hash >> (256 - max_shard_depth);

  int found? = false;
  int next_hop = random() % max_retranslators;
  int tries = 0;
  do {
    ;; if any shard hop - then just select the random hop
    ;; if the same needed - then check random retranslators until found
    next_hop_initstate = retranslator_init(next_hop, public_key, own_code, counter_code);
    next_hop_address = calc_address(next_hop_initstate);
    (_, int hop_addr_hash) = parse_std_addr(next_hop_address);
    int next_hop_shard = hop_addr_hash >> (256 - max_shard_depth);
    found? = any_shard_hop? ? true : (next_hop_shard == my_shard);
    next_hop += 1;
    if (next_hop >= max_retranslators) {
      next_hop = 0;
    }
    tries += 1;
    if ((tries >= shard_calc_tries_limit) & (~ found?)) {
      next_hop_address = my_address();
      found? = true;
    }
  } until found?;

  if (need_report?) {
    send_report(any_shard_hop?);
    if (amount > 0) {
      amount -= report_amount;
    }
  }
  var hop_msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(next_hop_address)
    .store_coins(amount > 0 ? amount : 0)
    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
    .store_ref(next_hop_initstate);
  var hop_msg_body = begin_cell()
    .store_uint(id, 16)
    .store_uint(remaining_hops, 32)
    .store_uint(split_hops, 8)
    .store_uint(txs_per_report, 16)
    .store_uint(same_shard_chance, 16)
    .store_slice(payload)
    .end_cell();
  hop_msg = hop_msg.store_ref(hop_msg_body);

  int send_mode = 128 + 2;
  if (amount) { send_mode = 3; }
  if (monkey_mode) { send_mode += 32; } ;; self-destroy if zero balance
  send_raw_message(hop_msg.end_cell(), send_mode);
}

{-
  retransalate#_ id:uint16 remaining_hops:uint32 split_hops:uint8 txs_per_report:uint16 same_shard_chance:uint16 payload:Cell = IntMsgBody;
-}

() main(int msg_value, cell in_msg_full, slice in_msg_body) {

  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
    return ();
  }
  
  check_spam_config();

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  if (flags & 1) {
    return ();
  }
  slice sender_address = cs~load_msg_addr();
  int sender_id = in_msg_body~load_uint(16);

  (id, _, public_key, own_code, counter_code) = load_data();

  slice expected_address = calc_address(retranslator_init(sender_id, public_key, own_code, counter_code));
  throw_unless(401, equal_slice_bits(expected_address, sender_address));

  remaining_hops = in_msg_body~load_uint(32);
  split_hops = in_msg_body~load_uint(8);
  txs_per_report = in_msg_body~load_uint(16);
  same_shard_chance = in_msg_body~load_uint(16);

  ifnot(remaining_hops) {
    return ();
  }
  remaining_hops -= 1;

  ifnot (monkey_mode) {
    ;; do not decrease the balance
    raw_reserve(pair_first(get_balance()) - msg_value, 2);
  }

  payload = in_msg_body; ;; to send with hop. giving an option to set msg size

  if(split_hops) {
    split_hops -= 1;

    msg_value -= 27372000; ;; gas + fwd, it will not make division by 2 perfect, but good enough
    retranslate(msg_value / 2);
    retranslate(0); ;; send the rest
  } else {
    retranslate(0); ;; send all incoming value
  }
}


() recv_external(slice in_msg) impure {
  var signature = in_msg~load_bits(512);
  var cs = in_msg;
  var (subwallet_id, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
  throw_if(35, valid_until <= now());
  (id, int stored_seqno, public_key, own_code, counter_code) = load_data();
  throw_unless(33, msg_seqno == stored_seqno);
  throw_unless(34, subwallet_id == id);
  throw_unless(35, check_signature(slice_hash(in_msg), signature, public_key));
  accept_message();

  var mode = cs~load_uint(8);
  if(mode == 255) { ;; retranslate mode. otherwise act like a wallet
      (int threads, ;; a number of tx-chains to start
       remaining_hops,
       split_hops,
       txs_per_report,
       same_shard_chance,
       int amount) = (cs~load_uint(8),
                      cs~load_uint(32),
                      cs~load_uint(8),
                      cs~load_uint(16),
                      cs~load_uint(16),
                      cs~load_coins());
      payload = cs;
      while (threads > 0) {
        retranslate(amount);
        threads -= 1;
      }
  } else {
      ;; just send a message
      send_raw_message(cs~load_ref(), mode);
  }
  set_data(pack_retranslator_data(id, stored_seqno + 1, public_key, own_code, counter_code));
}

;;
;; Get methods:
;;

int seqno() method_id {
  var (_, stored_seqno, _, _, _) = load_data();
  return stored_seqno;
}

int get_public_key() method_id {
  var (_, _, public_key, _, _) = load_data();
  return public_key;
}
